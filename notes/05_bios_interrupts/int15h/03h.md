# `03h`

## Key Topics

- [Introduction](#introduction)
    - [Behavior](#behavior)
- [Register Breakdown](#register-breakdown)
- [Examples](#examples)

---

## Introduction

BIOS interrupt 15h function 24h subfunction 03h provides comprehensive information about the system's A20 gate capabilities and initial state. This support query function enables system software to intelligently select the most appropriate A20 control strategy by revealing which control methods are available and how the system was configured at boot time. It is primarily used during early system initialization to build optimal A20 management routines tailored to the specific hardware platform.

### Behavior

When invoked, this function returns a detailed bitmap in the BX register indicating which A20 control interfaces are supported by the system hardware. Additionally, it provides information about the A20 state at system startup in the BH register. This allows software to determine whether to use BIOS calls, direct hardware manipulation, or a combination of approaches for A20 management.

The function sets the carry flag if A20 capability reporting is not supported by the BIOS. On systems where this query fails, software must employ heuristic approaches to determine available A20 control methods. The information returned by this function is particularly valuable for creating portable system software that can adapt to diverse hardware platforms with different A20 implementation characteristics.

---

## Register Breakdown

- `AH`: Main function number (`24h`) for A20 gate control
- `AL`: Subfunction selector (`03h`) for querying A20 support capabilities

**Return registers:**
- `BX`: Capability bitmap
  - `Bit 0`: Keyboard controller method supported
  - `Bit 1`: System Control Port A (Fast A20) supported
  - `Bit 2`: BIOS A20 gate control functions supported
- `BH`: Initial A20 state at boot (`00h` = always disabled, `01h` = may be enabled)
- `CF`: Carry Flag - Set to 1 if function not supported, clear (0) on success
- `AH`: Error code (if CF=1) - Typically `86h` for function not supported

---

## Examples

### Basic Usage

```asm
mov ax, 0x2403  ; AH=24h (A20 function), AL=03h (query support)
int 0x15        ; Call BIOS
jc not_supported ; Jump if function not available
test bl, 0x02   ; Check if Fast A20 is supported
jnz use_fast_a20 ; Use Fast A20 method if available
```

This basic example queries the system's A20 capabilities and checks specifically for Fast A20 support, allowing the software to select the most efficient enablement method available.

### Extended Example

```asm
; Intelligent A20 strategy selector
select_a20_strategy:
    mov ax, 0x2403      ; Query A20 capabilities
    int 0x15
    jc .legacy_fallback ; No BIOS support, use legacy detection
    
    ; Analyze capabilities and select optimal strategy
    test bl, 0x04       ; Check BIOS control support (bit 2)
    jnz .use_bios_method ; BIOS control is preferred
    
    test bl, 0x02       ; Check Fast A20 support (bit 1)
    jnz .use_fast_method ; Fast A20 is efficient fallback
    
    test bl, 0x01       ; Check keyboard controller support (bit 0)
    jnz .use_keyboard_method ; Last BIOS-supported option
    
.legacy_fallback:
    ; No BIOS-reported capabilities, try detection
    call detect_a20_methods
    ret

.use_bios_method:
    mov byte [a20_method], A20_BIOS
    ret

.use_fast_method:
    mov byte [a20_method], A20_FAST
    ret

.use_keyboard_method:
    mov byte [a20_method], A20_KEYBOARD
    ret

; Constants
A20_BIOS      equ 1
A20_FAST      equ 2
A20_KEYBOARD  equ 3

a20_method db 0
```

This extended example demonstrates an intelligent A20 strategy selector that analyzes the system's reported capabilities and chooses the optimal control method. The routine establishes a preference hierarchy with BIOS control as the first choice, followed by Fast A20, with keyboard controller as the last resort.

### Special Case

```asm
; Platform-specific optimization based on boot state
optimize_a20_initialization:
    mov ax, 0x2403      ; Query A20 capabilities and boot state
    int 0x15
    jc .generic_approach ; No capability info available
    
    ; Check if A20 might already be enabled at boot
    cmp bh, 0x01        ; BH=01h: A20 may be enabled on boot
    jne .must_enable    ; BH=00h: A20 always starts disabled
    
    ; A20 might be enabled already - check current state
    mov ax, 0x2402      ; Query current A20 status
    int 0x15
    jc .must_enable     ; Can't query status, assume disabled
    
    cmp al, 0x01
    je .a20_already_enabled ; Skip enablement if already active
    
.must_enable:
    ; A20 needs to be enabled - use best available method
    test bl, 0x02       ; Prefer Fast A20 if available
    jnz .use_fast_a20
    test bl, 0x04       ; Otherwise use BIOS control
    jnz .use_bios_a20
    ; Fall back to keyboard controller
    call enable_a20_keyboard
    jmp .completion
    
.use_fast_a20:
    call enable_a20_fast
    jmp .completion
    
.use_bios_a20:
    mov ax, 0x2401
    int 0x15
    
.completion:
    ; Verify A20 is now enabled
    call verify_a20_enabled
    ret

.a20_already_enabled:
    ; A20 was already active - skip enablement step
    mov si, a20_preenabled_msg
    call print_string
    ret

.generic_approach:
    ; No capability info - use safe generic approach
    call enable_a20_fast
    call verify_a20_enabled
    jnc .completion
    call enable_a20_keyboard ; Fallback if Fast A20 failed
    ret

a20_preenabled_msg db "A20 already enabled at boot", 0
```

This special case demonstrates advanced optimization that considers both the system's A20 capabilities and its initial boot state. By checking whether A20 might already be enabled at startup, the routine can avoid unnecessary enablement operations on systems that already have A20 active, improving boot efficiency and compatibility.

---
