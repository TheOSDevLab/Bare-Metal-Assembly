# `02h`

## Key Topics

- [Introduction](#introduction)
  - [Behavior](#behavior)
- [Register Breakdown](#register-breakdown)
- [Examples](#examples)

---

## Introduction

BIOS interrupt 15h function 24h subfunction 02h provides a standardized mechanism for querying the current status of the A20 address line. This allows system software to determine whether the A20 gate is currently enabled or disabled without performing low-level memory wrap-around tests.  

The function is useful during system initialization or when preparing to enter protected mode, where the correct A20 state is required to avoid address aliasing at the 1 MB boundary.

### Behavior

When invoked, this function queries the BIOS for the current A20 line state. The result is returned in **BL bit 0**, which reflects whether the A20 gate is enabled (set) or disabled (clear).  

Unlike some older documentation that suggests the result appears in `AL`, the **official IBM/AMI/Phoenix specification** defines the status in **BL**, not `AL`. The carry flag (CF) is set if the BIOS does not support the A20 control interface.

The call is non-destructive and does not modify the A20 state. If unsupported, system software should revert to a hardware or memory-based test to detect the A20 line status.

---

## Register Breakdown

- `AH`: 24h — A20 gate control function group  
- `AL`: 02h — Subfunction selector (Query A20 status)

**On return:**
- `CF`: Carry Flag — Set if function not supported, clear if successful  
- `BL` bit 0: A20 status (0 = disabled, 1 = enabled)  
- Other bits and registers are undefined unless otherwise documented  

No standard BIOS error codes are defined; if CF=1, assume the BIOS does not implement the A20 control interface.

---

## Examples

### Basic Usage

```asm
mov ax, 0x2402      ; AH=24h (A20), AL=02h (query)
int 0x15
jc not_supported     ; CF=1 → function not supported
test bl, 1
jnz a20_enabled      ; bit 0 = 1 → A20 enabled
; otherwise, A20 disabled
````

This example correctly checks the carry flag for support, then inspects bit 0 of `BL` to determine the current A20 state. If the BIOS doesn’t implement this call, a fallback method should be used.

---

### Extended Example

```asm
; Comprehensive A20 status detection routine
check_a20_status:
    ; Try BIOS query first
    mov ax, 0x2402
    int 0x15
    jc .memory_test        ; BIOS doesn’t support A20 control

    test bl, 1
    jnz .enabled           ; Bit 0 set → A20 enabled
    xor ax, ax             ; Return 0 = disabled
    ret

.memory_test:
    ; Fallback: perform wrap-around test
    push es
    mov ax, 0xFFFF
    mov es, ax
    mov byte [es:0x0010], 0x00

    mov ax, 0x0000
    mov es, ax
    mov byte [es:0x0010], 0xFF

    mov ax, 0xFFFF
    mov es, ax
    cmp byte [es:0x0010], 0x00
    pop es
    je .disabled
    mov ax, 0x0001
    ret

.disabled:
    xor ax, ax
    ret

.enabled:
    mov ax, 0x0001
    ret
```

This version accurately combines BIOS-based querying with a hardware-independent fallback. It uses the correct register (`BL`) for the BIOS response and performs a non-destructive memory test if unsupported.

---

### Special Case

```asm
; Monitor A20 line stability through repeated queries
monitor_a20_state:
    mov cx, 5
.check_loop:
    mov ax, 0x2402
    int 0x15
    jc .fallback

    test bl, 1
    jz .unstable           ; A20 unexpectedly disabled

    call delay_short
    loop .check_loop
    mov ax, 0x0001
    ret

.unstable:
    mov si, a20_unstable_msg
    call print_string
    xor ax, ax
    ret

.fallback:
    call memory_a20_test
    ret

delay_short:
    mov bx, 0x0100
.delay_loop:
    dec bx
    jnz .delay_loop
    ret

a20_unstable_msg db "Warning: A20 state unstable", 0
```

This example periodically checks the A20 state for consistency. It can detect unstable hardware or firmware implementations where A20 may unexpectedly toggle. This is particularly useful for debugging or early system initialization routines.

---
