# `00h`

## Key Topics

- [Introduction](#introduction)
    - [Behavior](#behavior)
- [Register Breakdown](#register-breakdown)
- [Examples](#examples)

---

## Introduction

BIOS interrupt 15h function 24h subfunction 00h provides a standardized interface for disabling the A20 address line. This function exists to maintain backward compatibility with legacy software that relies on the memory wrap-around behavior of the original IBM PC's 20-bit address bus. It is commonly used during system initialization sequences, hardware testing, and when reverting from protected mode back to real mode operations.

### Behavior

When invoked, this function instructs the BIOS to disable the A20 gate, forcing the 21st address line to remain low. This causes any memory access above the 1MB boundary (address 0x100000 and beyond) to wrap around to the beginning of the first megabyte (address 0x00000). The BIOS handles the hardware-specific implementation details, which may involve programming the keyboard controller, system control port, or other platform-specific mechanisms.

Special limitations include potential failure on systems where the BIOS does not support A20 control or when the keyboard controller is locked. Some modern systems may ignore this call entirely if they no longer implement A20 gate hardware. The function sets the carry flag on failure, allowing software to detect when the operation was unsuccessful.

---

## Register Breakdown

- `AH`: Main function number (`24h`) for A20 gate control
- `AL`: Subfunction selector (`00h`) specifically for disabling A20
- Other registers are typically preserved across the call

**Return registers:**
- `CF`: Carry Flag - Set to 1 on error, clear (0) on success
- `AH`: Error code (if CF=1) - `01h` keyboard controller locked, `86h` function not supported

---

## Examples

### Basic Usage

```asm
mov ax, 0x2400  ; AH=24h (A20 function), AL=00h (disable)
int 0x15        ; Call BIOS
jc error_handler ; Jump if carry set (error occurred)
```

This code attempts to disable the A20 gate through the BIOS interface. If successful, the system will exhibit memory wrap-around behavior at the 1MB boundary. If failed, control transfers to an error handler to implement alternative strategies.

### Extended Example

```asm
; Comprehensive A20 state management routine
disable_a20_bios:
    mov ax, 0x2400      ; Function: disable A20
    int 0x15            ; Call BIOS
    jnc .success        ; Jump if no error
    
    ; BIOS method failed, handle error
    mov si, bios_a20_error_msg
    call print_string
    ; Fall through to hardware methods
    
.success:
    ret

bios_a20_error_msg db "BIOS A20 disable failed", 0
```

This example demonstrates a complete A20 management approach. The routine includes basic error handling and provides a fallback path for when BIOS control is unavailable.

### Special Case

```asm
; Safe A20 disable with support verification
mov ax, 0x2403      ; First check for BIOS A20 support
int 0x15
jc no_bios_support  ; BIOS doesn't support A20 functions

test bl, 0x02       ; Check if BIOS A20 control is supported
jz no_bios_control  ; BIOS doesn't support software control

mov ax, 0x2400      ; Safe to call BIOS disable
int 0x15            ; Disable A20 gate

no_bios_support:
    ; Implement alternative A20 disable methods
no_bios_control:
    ; Handle lack of BIOS control capability
```

This special case demonstrates the recommended practice of verifying BIOS A20 support before attempting to use the disable function. This prevents unnecessary errors and allows for graceful fallback to hardware-specific control methods when BIOS support is limited or unavailable.

---
