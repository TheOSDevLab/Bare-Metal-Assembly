# `02h`

## Key Topics

- [Introduction](#introduction)
    - [Behavior](#behavior)
- [Register Breakdown](#register-breakdown)
- [Examples](#examples)

---

## Introduction

BIOS interrupt 15h function 24h subfunction 02h provides a reliable method for querying the current status of the A20 address line. This diagnostic function allows system software to determine whether the A20 gate is currently enabled or disabled without resorting to low-level memory testing techniques. It is particularly valuable during system initialization, hardware debugging, and in scenarios where the A20 state must be verified before proceeding with mode transitions or memory management operations.

### Behavior

When invoked, this function queries the BIOS to determine the current hardware state of the A20 gate. The BIOS returns a clear status indication in the AL register, specifying whether the A20 line is actively enabled or disabled. This provides a more reliable alternative to memory-based A20 detection methods, which can be affected by caching, memory mapping, or other system-specific factors.

The function sets the carry flag if the query capability is not supported by the BIOS. On systems where A20 status reporting is unavailable, software must fall back to traditional memory wrap-around tests. The query is non-destructive and does not modify the A20 state, making it safe for diagnostic use at any point during system operation.

---

## Register Breakdown

- `AH`: Main function number (`24h`) for A20 gate control
- `AL`: Subfunction selector (`02h`) specifically for querying A20 status

**Return registers:**
- `AL`: Status result - `00h` indicates A20 disabled, `01h` indicates A20 enabled
- `CF`: Carry Flag - Set to 1 if function not supported, clear (0) on success
- `AH`: Error code (if CF=1) - Typically `86h` for function not supported

---

## Examples

### Basic Usage

```asm
mov ax, 0x2402  ; AH=24h (A20 function), AL=02h (query status)
int 0x15        ; Call BIOS
jc not_supported ; Jump if function not available
cmp al, 0x01    ; Compare with 'enabled' status
je a20_active   ; Jump if A20 is enabled
```

This basic example queries the A20 status and branches based on the result. The carry flag check ensures graceful handling of systems that don't support this BIOS function.

### Extended Example

```asm
; Comprehensive A20 status checking routine
check_a20_status:
    ; First try BIOS query method
    mov ax, 0x2402      ; Query A20 status
    int 0x15
    jnc .bios_success   ; BIOS method worked
    
    ; BIOS query not supported, fall back to memory test
    call memory_a20_test
    ret
    
.bios_success:
    cmp al, 0x01
    je .enabled
    mov ax, 0x0000      ; Return 0 for disabled
    ret
    
.enabled:
    mov ax, 0x0001      ; Return 1 for enabled
    ret

memory_a20_test:
    ; Traditional memory wrap-around test
    push es
    mov ax, 0xFFFF
    mov es, ax
    mov byte [es:0x0010], 0x00  ; Write to 0x100000 if A20 enabled
    
    mov ax, 0x0000
    mov es, ax
    mov byte [es:0x0000], 0xFF  ; Write to 0x000000
    
    mov ax, 0xFFFF
    mov es, ax
    cmp byte [es:0x0010], 0x00  ; Check if value changed
    pop es
    je .disabled
    mov ax, 0x0001      ; Enabled
    ret
.disabled:
    mov ax, 0x0000      ; Disabled
    ret
```

This extended example demonstrates a robust A20 detection strategy that prefers the BIOS query method when available but gracefully falls back to traditional memory testing on older systems. The routine provides a consistent interface regardless of the underlying detection mechanism.

### Special Case

```asm
; A20 state monitoring with periodic verification
monitor_a20_state:
    mov cx, 0x0005      ; Number of verification attempts
.verification_loop:
    mov ax, 0x2402      ; Query current A20 status
    int 0x15
    jc .use_fallback    ; BIOS query failed
    
    cmp al, 0x01
    jne .a20_disabled   ; A20 unexpectedly disabled
    
    ; A20 is enabled, wait and verify stability
    call delay_short
    loop .verification_loop
    
    ; All verifications passed
    mov ax, 0x0001
    ret

.a20_disabled:
    ; A20 became disabled unexpectedly
    mov si, a20_unstable_msg
    call print_string
    mov ax, 0x0000
    ret

.use_fallback:
    ; Implement alternative verification
    call memory_a20_test
    ret

delay_short:
    ; Short delay implementation
    mov bx, 0x0100
.delay_loop:
    dec bx
    jnz .delay_loop
    ret

a20_unstable_msg db "Warning: A20 state unstable", 0
```

This special case demonstrates A20 state monitoring with multiple verification attempts, useful for detecting unstable A20 gates or hardware that may spontaneously disable the A20 line. The routine provides enhanced reliability for systems where A20 stability is critical for operation.

---
