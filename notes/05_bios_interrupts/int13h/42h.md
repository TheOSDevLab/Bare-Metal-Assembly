# `42h`

## Key Topics

- [Introduction](#introduction)
    - [Behavior](#behavior)
- [Register Breakdown](#register-breakdown)
- [Examples](#examples)

---

## Introduction

BIOS Interrupt 13h Function 42h is part of the Enhanced Disk Drive Services (EDD) and provides a way to read disk sectors using 64-bit Logical Block Addressing (LBA). It was developed to overcome the severe capacity limitations of the older CHS (Cylinder-Head-Sector) addressing method, which could not access disks larger than approximately 8 GB . This function is commonly used by modern bootloaders, operating system kernels during early boot stages, and system utilities that require low-level disk access before protected mode drivers are available.

### Behavior

The function reads the specified number of disk sectors into memory using a Disk Address Packet (DAP) structure. The BIOS uses the LBA address from the DAP and transfers the data directly to the specified memory buffer. If the underlying hardware does not support LBA addressing, the BIOS automatically performs the necessary conversion.

Key limitations include:

- **Sector Count**: Many BIOS implementations limit the number of sectors that can be transferred in a single call to **127 sectors** (approximately 65 KB) . Some BIOSes may allow reading up to 127 sectors to guarantee the transfer does not cross a 64KB memory boundary .
- **Memory Boundary**: The transfer must not cross a 64-kilobyte boundary within a physical memory page. Some BIOSes are strict about this and will return an error (AH=09h) if violated .

The carry flag (CF) is cleared on success and set on error, with AH containing the error code. On error, the number of sectors actually read may be stored in the DAP's sector count field, but this should not be relied upon for handling partial reads.

---

## Register Breakdown

- `AH`: Function number (`42h`).
- `DL`: Drive number (0x80 for first hard disk, 0x00 for first floppy).
- `DS:SI`: Segment:Offset pointer to a Disk Address Packet (DAP) structure in memory.

The following registers are typically ignored or preserved: `AL`, `BH`, `BL`, `CX`, `DH`.

**Disk Address Packet Structure** :

- **Offset 0**: `size` (1 byte) - Packet size (`10h` for 16-byte version, `18h` for 24-byte version).
- **Offset 1**: `reserved` (1 byte) - Always 0.
- **Offset 2**: `count` (2 bytes) - Number of sectors to transfer (max 127 on some BIOSes).
- **Offset 4**: `offset` (2 bytes) - Offset of the transfer buffer.
- **Offset 6**: `segment` (2 bytes) - Segment of the transfer buffer.
- **Offset 8**: `lba_low` (4 bytes) - Lower 32 bits of 48-bit starting LBA.
- **Offset 12**: `lba_high` (4 bytes) - Upper 32 bits of 48-bit starting LBA (set to 0 for typical sub-2TB drives).

---

## Examples

### Basic Usage

```asm
DAPACK:
    db 0x10        ; Packet size (16 bytes)
    db 0           ; Reserved
    dw 1           ; Read 1 sector
    dw 0x8000      ; Buffer offset
    dw 0x0000      ; Buffer segment
    dd 1           ; LBA #1
    dd 0           ; High 32-bits of LBA

mov ah, 0x42       ; Function 42h: Extended Read
mov dl, 0x80       ; First hard disk
mov si, DAPACK     ; DS:SI points to Disk Address Packet
int 0x13           ; Call BIOS
jc disk_error      ; Jump if error (Carry Flag set)
```

This snippet reads one sector from LBA address 1 of the first hard drive into memory at 0000:8000. This is typical for loading a bootloader's second stage or a kernel.

### Extended Example

```asm
; Read multiple chunks of a kernel from disk
mov ax, 0x1000
mov es, ax         ; Destination segment
mov di, 0x0000     ; Destination offset
mov dword [LBA], 1 ; Starting LBA

.load_loop:
    ; Set up DAP for each read
    mov si, DAPACK
    mov word [DAPACK.count], 16    ; Read 16 sectors at a time (8KB)
    mov word [DAPACK.offset], di   ; Current offset
    mov word [DAPACK.segment], es  ; Current segment
    mov eax, [LBA]
    mov dword [DAPACK.lba_low], eax

    mov ah, 0x42
    mov dl, 0x80
    int 0x13
    jc disk_error

    ; Update position for next chunk
    mov ax, es
    add ax, (512 * 16) / 16    ; Advance segment by 512 paragraphs
    mov es, ax

    add dword [LBA], 16        ; Advance LBA by 16 sectors

    cmp dword [LBA], 256       ; Stop after 256 sectors (128KB)
    jl .load_loop

jmp 0x1000:0x0000              ; Jump to loaded kernel

DAPACK:
    db 0x10, 0
    dw 16         ; Sectors to read
    dw 0          ; Offset (updated in code)
    dw 0          ; Segment (updated in code)
LBA dd 1          ; Current LBA
    dd 0
```

This example demonstrates loading a kernel in chunks. It reads 16 sectors per INT 13h call, updating the buffer pointer and LBA each time. This approach handles larger loads while respecting potential BIOS sector count limits.

If you require clarification on this example, a comprehensive breakdown is available in [the detailed analysis file](extra/example_detailed_analysis.md).

### Special Case

```asm
; Check for INT 13h Extensions support before using AH=42h
mov ah, 0x41       ; Function 41h: Check Extensions Present
mov bx, 0x55AA     ; Signature
mov dl, 0x80       ; Drive number
int 0x13
jc no_extensions   ; CF set if not supported
cmp bx, 0xAA55     ; BX must be 0xAA55 on success
jne no_extensions

; Extensions are supported - safe to use AH=42h
mov ah, 0x42
mov dl, 0x80
mov si, DAPACK
int 0x13
jc disk_error

no_extensions:
    ; Fall back to CHS reading (AH=02h) or display error
```

This special case shows how to verify that the BIOS supports INT 13h extensions before attempting to use function 42h. This is crucial for compatibility with older systems and should be included in any robust bootloader .

---
